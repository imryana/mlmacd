"""
notifier.py — Email and Telegram alert delivery for scanner signals.

Classes
-------
EmailNotifier
    Sends an HTML email with a table of trade cards using SMTP.
    Credentials are loaded from .env (EMAIL_USER, EMAIL_PASS).

TelegramNotifier
    Posts one formatted message per trade card via the Telegram Bot API.
    Credentials are loaded from .env (TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID).

NotificationManager
    Orchestrates both notifiers:
      - Filters signals below config.alerts.min_confidence_to_alert
      - Deduplicates: skips a ticker if the same signal was already sent today
      - Logs every sent alert to data/alerts_log.csv

Run standalone:
    python -m alerts.notifier
"""

import csv
import logging
import os
import pathlib
import smtplib
import ssl
from datetime import date
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

import pandas as pd
import requests
import yaml
from dotenv import load_dotenv

log = logging.getLogger(__name__)

_ROOT = pathlib.Path(__file__).resolve().parents[1]
_ENV_PATH  = _ROOT / ".env"
_LOG_PATH  = _ROOT / "data" / "alerts_log.csv"
_LOG_COLS  = ["date", "ticker", "signal_name", "confidence", "channel"]


# ── Shared helpers ────────────────────────────────────────────────────────


def _load_config() -> dict:
    """Load and return config.yaml as a dict."""
    with open(_ROOT / "config" / "config.yaml") as fh:
        return yaml.safe_load(fh)


def _load_env() -> None:
    """Load .env file if present (silently skip if absent)."""
    if _ENV_PATH.exists():
        load_dotenv(_ENV_PATH)


def _cards_path() -> pathlib.Path:
    """Return path to saved trade cards parquet."""
    return _ROOT / "data" / "processed" / "trade_cards.parquet"


# ── EmailNotifier ─────────────────────────────────────────────────────────


class EmailNotifier:
    """
    Sends an HTML email containing a table of trade card signals.

    Reads EMAIL_USER and EMAIL_PASS from the environment (loaded from .env).

    Parameters
    ----------
    cfg : dict
        Full config dict.  Uses ``cfg["alerts"]`` section for SMTP settings.
    """

    def __init__(self, cfg: dict) -> None:
        self.cfg      = cfg
        self.alerts   = cfg.get("alerts", {})
        self.smtp_host = self.alerts.get("email_smtp_server", "smtp.gmail.com")
        self.smtp_port = int(self.alerts.get("email_port", 587))
        _load_env()
        self.user     = os.getenv("EMAIL_USER", "")
        self.password = os.getenv("EMAIL_PASS", "")

    # ── Internal helpers ──────────────────────────────────────────────────

    def _build_html(self, trade_cards: pd.DataFrame) -> str:
        """
        Build an HTML email body from the trade cards DataFrame.

        Parameters
        ----------
        trade_cards : pd.DataFrame
            Rows to include in the email table.

        Returns
        -------
        str
            Full HTML document string.
        """
        display_cols = [
            c for c in (
                "ticker", "signal_name", "confidence", "price",
                "limit_entry", "stop_loss", "take_profit", "rr_ratio",
                "position_units", "position_value", "position_pct",
            ) if c in trade_cards.columns
        ]

        rows_html = ""
        for _, row in trade_cards[display_cols].iterrows():
            sig = str(row.get("signal_name", ""))
            colour = "#d4edda" if sig == "LONG" else "#f8d7da" if sig == "SHORT" else "#fff"
            cells = "".join(
                f"<td style='padding:6px 10px;border:1px solid #dee2e6'>{val}</td>"
                for val in row.values
            )
            rows_html += f"<tr style='background:{colour}'>{cells}</tr>"

        headers = "".join(
            f"<th style='padding:8px 10px;background:#343a40;color:#fff;border:1px solid #444'>"
            f"{col.replace('_',' ').title()}</th>"
            for col in display_cols
        )

        scan_date = date.today().isoformat()
        return f"""
        <html><body style='font-family:Arial,sans-serif;'>
        <h2 style='color:#343a40'>ML Signal Scanner — {scan_date}</h2>
        <p>{len(trade_cards)} signal(s) above confidence threshold.</p>
        <table style='border-collapse:collapse;font-size:13px'>
          <thead><tr>{headers}</tr></thead>
          <tbody>{rows_html}</tbody>
        </table>
        <br><p style='color:#6c757d;font-size:11px'>
          Generated by S&P 500 ML Signal Scanner
        </p>
        </body></html>
        """

    # ── Public API ────────────────────────────────────────────────────────

    def send_signal_alert(self, trade_cards: pd.DataFrame) -> bool:
        """
        Send an HTML email with a table of trade card signals.

        Parameters
        ----------
        trade_cards : pd.DataFrame
            One or more rows from the trade cards DataFrame.

        Returns
        -------
        bool
            True if the email was sent successfully, False otherwise.
        """
        if not self.user or not self.password:
            log.warning("Email credentials not set (EMAIL_USER / EMAIL_PASS).")
            return False

        if trade_cards.empty:
            log.info("No trade cards to email.")
            return False

        msg = MIMEMultipart("alternative")
        msg["Subject"] = f"ML Scanner — {len(trade_cards)} Signal(s) — {date.today()}"
        msg["From"]    = self.user
        msg["To"]      = self.user

        html_body = self._build_html(trade_cards)
        msg.attach(MIMEText(html_body, "html"))

        try:
            context = ssl.create_default_context()
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                server.ehlo()
                server.starttls(context=context)
                server.login(self.user, self.password)
                server.sendmail(self.user, self.user, msg.as_string())
            log.info("Email sent to %s.", self.user)
            return True
        except Exception as exc:
            log.error("Failed to send email: %s", exc)
            return False


# ── TelegramNotifier ──────────────────────────────────────────────────────


class TelegramNotifier:
    """
    Posts one formatted Telegram message per trade card signal.

    Reads TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID from the environment.

    Parameters
    ----------
    cfg : dict
        Full config dict.
    """

    _API_URL = "https://api.telegram.org/bot{token}/sendMessage"

    def __init__(self, cfg: dict) -> None:
        self.cfg = cfg
        _load_env()
        self.token   = os.getenv("TELEGRAM_BOT_TOKEN", "")
        self.chat_id = os.getenv("TELEGRAM_CHAT_ID", "")

    # ── Internal helpers ──────────────────────────────────────────────────

    def _format_message(self, card: dict | pd.Series) -> str:
        """
        Format one trade card as a Telegram message string.

        Parameters
        ----------
        card : dict or pd.Series

        Returns
        -------
        str
        """
        if isinstance(card, pd.Series):
            card = card.to_dict()

        sig_name = str(card.get("signal_name", "SIGNAL"))
        ticker   = str(card.get("ticker", ""))
        conf     = float(card.get("confidence", 0))
        regime   = str(card.get("regime_name", card.get("regime", "")))
        adx      = float(card.get("adx", 0))
        rsi      = float(card.get("rsi", 0))
        entry    = float(card.get("limit_entry", card.get("price", 0)))
        stop     = float(card.get("stop_loss", 0))
        target   = float(card.get("take_profit", 0))
        rr       = float(card.get("rr_ratio", 0))
        pos_pct  = float(card.get("position_pct", 0))

        return (
            f"[{sig_name}] {ticker} — Confidence: {conf:.0%}\n"
            f"Regime: {regime} | ADX: {adx:.1f} | RSI: {rsi:.1f}\n"
            f"Entry: {entry:.2f} | Stop: {stop:.2f} | Target: {target:.2f}\n"
            f"R:R: {rr:.1f}:1 | Size: {pos_pct:.1f}% portfolio"
        )

    # ── Public API ────────────────────────────────────────────────────────

    def send_signal_alert(self, card: dict | pd.Series) -> bool:
        """
        Send a Telegram message for one trade card.

        Parameters
        ----------
        card : dict or pd.Series
            A single trade card row.

        Returns
        -------
        bool
            True if sent successfully.
        """
        if not self.token or not self.chat_id:
            log.warning("Telegram credentials not set (TELEGRAM_BOT_TOKEN / TELEGRAM_CHAT_ID).")
            return False

        text = self._format_message(card)
        url  = self._API_URL.format(token=self.token)

        try:
            resp = requests.post(
                url,
                json={"chat_id": self.chat_id, "text": text},
                timeout=10,
            )
            resp.raise_for_status()
            log.info("Telegram message sent for %s.", card.get("ticker", "?"))
            return True
        except Exception as exc:
            log.error("Telegram send failed: %s", exc)
            return False


# ── NotificationManager ───────────────────────────────────────────────────


class NotificationManager:
    """
    Orchestrates email and Telegram notifications for scanner signals.

    Responsibilities:
      - Filter cards below ``config.alerts.min_confidence_to_alert``
      - Deduplicate: skip ticker+signal combinations already sent today
      - Log every sent alert to ``data/alerts_log.csv``

    Parameters
    ----------
    cfg : dict
        Full config dict.
    """

    def __init__(self, cfg: dict) -> None:
        self.cfg          = cfg
        self.alerts_cfg   = cfg.get("alerts", {})
        self.min_conf     = float(self.alerts_cfg.get("min_confidence_to_alert", 0.65))
        self.email_on     = bool(self.alerts_cfg.get("email_enabled", False))
        self.telegram_on  = bool(self.alerts_cfg.get("telegram_enabled", False))

        self.email_notifier    = EmailNotifier(cfg)    if self.email_on    else None
        self.telegram_notifier = TelegramNotifier(cfg) if self.telegram_on else None

        self._today_str = date.today().isoformat()

    # ── Deduplication ─────────────────────────────────────────────────────

    def _load_sent_today(self) -> set[tuple[str, str]]:
        """
        Return the set of (ticker, signal_name) pairs already sent today.

        Returns
        -------
        set[tuple[str, str]]
        """
        if not _LOG_PATH.exists():
            return set()
        try:
            df  = pd.read_csv(_LOG_PATH, dtype=str)
            today_df = df[df["date"] == self._today_str]
            return set(zip(today_df["ticker"], today_df["signal_name"]))
        except Exception:
            return set()

    def _log_alert(self, ticker: str, signal_name: str, confidence: float, channel: str) -> None:
        """
        Append one row to the alerts log CSV.

        Parameters
        ----------
        ticker, signal_name : str
        confidence : float
        channel : str
            ``"email"`` or ``"telegram"``.
        """
        _LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
        write_header = not _LOG_PATH.exists()
        try:
            with open(_LOG_PATH, "a", newline="") as fh:
                writer = csv.DictWriter(fh, fieldnames=_LOG_COLS)
                if write_header:
                    writer.writeheader()
                writer.writerow({
                    "date":        self._today_str,
                    "ticker":      ticker,
                    "signal_name": signal_name,
                    "confidence":  f"{confidence:.4f}",
                    "channel":     channel,
                })
        except Exception as exc:
            log.warning("Could not write alerts log: %s", exc)

    # ── Public API ────────────────────────────────────────────────────────

    def send_alerts(self, trade_cards: pd.DataFrame) -> dict:
        """
        Filter, deduplicate, and dispatch alerts for the given trade cards.

        Parameters
        ----------
        trade_cards : pd.DataFrame
            Output of ``signals.trade_setup.build_all_trade_cards()``.

        Returns
        -------
        dict
            Summary with keys ``sent``, ``skipped_conf``, ``skipped_dedup``.
        """
        if trade_cards.empty:
            log.info("No trade cards to notify.")
            return {"sent": 0, "skipped_conf": 0, "skipped_dedup": 0}

        sent_today   = self._load_sent_today()
        skip_conf    = 0
        skip_dedup   = 0
        sent_count   = 0
        email_batch  = []

        for _, card in trade_cards.iterrows():
            ticker     = str(card.get("ticker", ""))
            sig_name   = str(card.get("signal_name", ""))
            confidence = float(card.get("confidence", 0))

            # Confidence filter
            if confidence < self.min_conf:
                skip_conf += 1
                continue

            # Deduplication
            if (ticker, sig_name) in sent_today:
                skip_dedup += 1
                log.debug("Dedup: %s %s already sent today.", ticker, sig_name)
                continue

            # Telegram (one message per card)
            if self.telegram_on and self.telegram_notifier:
                ok = self.telegram_notifier.send_signal_alert(card)
                if ok:
                    self._log_alert(ticker, sig_name, confidence, "telegram")
                    sent_today.add((ticker, sig_name))

            # Collect for email batch
            email_batch.append(card)
            sent_count += 1

        # Email (one message for all cards)
        if self.email_on and self.email_notifier and email_batch:
            batch_df = pd.DataFrame(email_batch)
            ok = self.email_notifier.send_signal_alert(batch_df)
            if ok:
                for card in email_batch:
                    self._log_alert(
                        str(card.get("ticker", "")),
                        str(card.get("signal_name", "")),
                        float(card.get("confidence", 0)),
                        "email",
                    )

        log.info(
            "Alerts: %d sent, %d skipped (confidence), %d skipped (dedup).",
            sent_count, skip_conf, skip_dedup,
        )
        return {"sent": sent_count, "skipped_conf": skip_conf, "skipped_dedup": skip_dedup}


# ── Entry point ───────────────────────────────────────────────────────────


def main() -> None:
    """Load latest trade cards and send alerts."""
    logging.basicConfig(level=logging.INFO, format="%(levelname)s  %(message)s")

    cfg        = _load_config()
    cards_path = _cards_path()

    if not cards_path.exists():
        print("No trade cards found. Run `python -m signals.trade_setup` first.")
        return

    trade_cards = pd.read_parquet(cards_path)
    log.info("Loaded %d trade card(s).", len(trade_cards))

    manager = NotificationManager(cfg)
    result  = manager.send_alerts(trade_cards)

    print(f"\nAlert summary:")
    print(f"  Sent          : {result['sent']}")
    print(f"  Skipped (conf): {result['skipped_conf']}")
    print(f"  Skipped (dedup): {result['skipped_dedup']}")

    if not cfg.get("alerts", {}).get("email_enabled") and \
       not cfg.get("alerts", {}).get("telegram_enabled"):
        print("\nBoth email and Telegram are disabled in config.yaml.")
        print("Enable them and set credentials in .env to receive alerts.")


if __name__ == "__main__":
    main()
